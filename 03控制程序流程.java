3.1 使用Java运算符

3.1.1 优先级
程序员经常都会忘记运算符优先级 解决办法是用括号明确计算顺序

3.1.2 赋值
对于一个基本数据类型 由于基本数据类型容纳了实际的值 所以比如 A = B 结果就是A变成了B 但是B不受影响
对于一个对象 因为对一个对象进行操作的时候 我们真正操作的是它的句柄
也就是说如果“从一个对象到另外一个对象”赋值 实际就是将句柄从一个地方复制到另一个地方 比如 C = D 那么最终的结果就是C和D都指向最初只有D指向的对象
下面是一个例子
class Number {
  int i;
}

public class Assignment {
  public static void main(String[] args) {
    Number n1 = new Number();
    Number n2 = new Number();
    n1.i = 9;
    n2.i = 47;
    System.out.println("1: n1.i: " + n1.i +
      ", n2.i: " + n2.i);
    n1 = n2;// 使得n1指向n2
    System.out.println("2: n1.i: " + n1.i +
      ", n2.i: " + n2.i);
    n1.i = 27;
    System.out.println("3: n1.i: " + n1.i +
      ", n2.i: " + n2.i);
  }
}
Number类非常简单，它的两个实例（n1和n2）是在main()里创建的。每个Number中的i值都赋予了一个不同的值。
随后，将n2赋给n1，而且n1发生改变。在许多程序设计语言中，我们都希望n1和n2任何时候都相互独立。
但由于我们已赋予了一个句柄，所以下面才是真实的输出：
1: n1.i: 9, n2.i: 47
2: n1.i: 47, n2.i: 47
3: n1.i: 27, n2.i: 27
看来改变n1的同时也改变了n2！
这是由于无论n1还是n2都包含了相同的句柄，它指向相同的对象
（最初的句柄位于n1内部，指向容纳了值9的一个对象。在赋值过程中，那个句柄实际已经丢失；它的对象会由“垃圾收集器”自动清除）。 
这种特殊的现象通常也叫作“别名”，是Java操作对象的一种基本方式。
但假若不愿意在这种情况下出现别名，又该怎么操作呢？可放弃赋值，并写入下述代码：

n1.i = n2.i;

这样便可保留两个独立的对象，而不是将n1和n2绑定到相同的对象。但您很快就会意识到，这样做会使对象内部的字段处理发生混乱 并与标准的面向对象设计准则相悖

3.1.4 自动递增和递减
对于++A和--A 会先执行运算 再生成值
对于A++和A-- 会先生成值 再进行运算

3.1.5 关系运算符
对于基本数据类型而言 直接用== != 进行比较即可
对于对象的比较而言 使用 == != 和 equals 都可以 
但是
== != 比较的是对象的句柄 
equals() 比较的是对象的实际内容

3.1.6 逻辑运算符
这里存在一个“短路”情况 也就是说：
当当前表达式已经可以得到真或假的情况 就不必再去求解剩余的表达式部分的真假了

3.1.8 移位运算符
左移位运算符（<<）能将运算符左边的运算对象向左移动运算符右侧指定的位数（在低位补0）。
“有符号”右移位运算符（>>）则将运算符左边的运算对象向右移动运算符右侧指定的位数。
“有符号”右移位运算符使用了“符号扩展”：
若值为正，则在高位插入0；
若值为负，则在高位插入1。
Java也添加了一种“无符号”右移位运算符（>>>），它使用了“零扩展”：无论正负，都在高位插入0。

3.1.9 三元if-else运算符
下面便是一个例子：
static int ternary(int i) {
return i < 10 ? i * 100 : i * 10;
}
可以看出，假设用普通的if-else结构写上述代码，代码量会比上面多出许多。如下所示：
static int alternative(int i) {
if (i < 10)
return i * 100;
return i * 10;
}
但第二种形式更易理解，而且不要求更多的录入。所以在挑选三元运算符时，请务必权衡一下利弊。

3.1.10 逗号运算符
在Java里，唯一需要用到逗号的地方就是for循环。

3.1.13 造型（Cast）运算符
为进行一次造型，要将括号中希望的数据类型置于其他任何值的左侧：
void casts() {
int i = 200;
long l = (long)i;
long l2 = (long)200;
}
在Java中，造型是比较安全的操作
但当进行“缩小转换”的时候，就可以面临信息丢失的危险 所以此时编译器会强制我们进行造型
但当进行“放大转换”的时候，则不必明确造型

2.转型
。通常，表达式中最大的数据类型是决定了表达式最终结果大小的那个类型。
若将一个float值与一个double值相乘，结果就是double；
如将一个int和一个long值相加，则结果为long。

3.1.14 Java没有针对基本数据类型的sizeof()
Java不需要sizeof()运算符来满足这方面的需要，因为所有数据类型在所有机器的大小都是相同的。
我们不必考虑移植问题——Java本身就是一种“与平台无关”的语言。

3.2 执行控制

3.2.1 真和假
注意！Java不允许我们将一个数字作为布尔值使用（但是在C和C++里面是允许的 真是非0 假是0）

3.2.3 反复
Java里唯一用到逗号运算符的地方就是for循环的控制表达式。
在控制表达式的初始化和步进控制部分，我们可使用一系列由逗号分隔的语句。
而且那些语句均会独立执行。前面的例子已运用了这种能力，下面则是另一个例子：
//: CommaOperator.java
public class CommaOperator {
  public static void main(String[] args) {
    for(int i = 1, j = i + 10; i < 5; i++, j = i * 2) {
      System.out.println("i= " + i + " j= " + j);
    }
  }
} ///:~

3.2.6 中断和继续
大家还会看到continue移回循环顶部，同时不完成剩余的内容
比如对于for(A; B; C) {
  ...a
  continue;
  ...b
}
那么在执行到continue;的时候
b不再执行 但是C会被执行

1.臭名昭著的goto
尽管goto仍是Java的一个保留字，但并未在语言中得到正式使用；Java没有goto。
然而，在break和continue这两个关键字的身上，我们仍然能看出一些goto的影子。
它并不属于一次跳转，而是中断循环语句的一种方法。之所以把它们纳入goto问题中一起讨论，是由于它们使用了相同的机制：标签。
“标签”是后面跟一个冒号的标识符，就象下面这样：

label1:
外部循环{
内部循环{
//...
break; //1
//...
continue; //2
//...
continue label1; //3
//...
break label1; //4
}
----因为用的不多 暂时不表 详见Java编程思想 3.2

3.2.7 开关
“开关”（Switch）有时也被划分为一种“选择语句”。
根据一个整数表达式的值，switch语句可从一系列代码选出一段执行。
它的格式如下：
switch(整数选择因子) {
case 整数值1 : 语句; break;
case 整数值2 : 语句; break;
case 整数值3 : 语句; break;
case 整数值4 : 语句; break;
case 整数值5 : 语句; break;
//..
default:语句;
}
其中，“整数选择因子”是一个特殊的表达式，能产生整数值。switch能将整数选择因子的结果与每个整数值比较。若发现相符的，就执行对应的语句（简单或复合语句）。若没有发现相符的，就执行default语句。
在上面的定义中，大家会注意到每个case均以一个break结尾。这样可使执行流程跳转至switch主体的末尾。这是构建switch语句的一种传统方式，但break是可选的。若省略break，会继续执行后面的case语句的代码，直到遇到一个break为止。尽管通常不想出现这种情况，但对有经验的程序员来说，也许能够善加利用。注意最后的default语句没有break，因为执行流程已到了break的跳转目的地。当然，如果考虑到编程风格方面的原因，完全可以在default语句的末尾放置一个break，尽管它并没有任何实际的用处。
  
3.3 总结
下一章 将会讨论对象的初始化和清除问题，再后面则讲述隐藏的基本实现方法

3.4 练习
(1) 写一个程序，打印出1到100间的整数。
for(int i = 1; i < 101; i++){
  System.out.println(i);
}
(2) 修改练习(1)，在值为47时用一个break退出程序。亦可换成return试试。
for(int i = 1; i < 101; i++){
  System.out.println(i);
  if(i == 47)
    break;
}
(3) 创建一个switch语句，为每一种case都显示一条消息。并将switch置入一个for循环里，令其尝试每一种case。在每个case后面都放置一个break，并对其进行测试。然后，删除break，看看会有什么情况出现。
for(int i = 1; i < 5; i++){
  switch(i){
    case 1 : System.out.println("i");
      break;
    case 2 : System.out.println("i");
      break;
    default : System.out.println("i");
  }
}

  
