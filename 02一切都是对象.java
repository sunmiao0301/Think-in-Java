2 一切都是对象
Java乃至Java程序内的一切都是对象
PS： 句柄 在其他Java参考书中 被人称作一个“引用” 甚至一个“指针”

2.1 用句柄（变量）操纵对象
可创建一个String句柄：
String s;
但这里创建的只是句柄，并不是对象。若此时向s发送一条消息，就会获得一个错误（运行期）。
这是由于s实际并未与任何东西连接
因此，一种更安全的做法是：创建一个句柄时，记住无论如何都进行初始化：
String s = "asdf";
然而，这里采用的是一种特殊类型：字串可用加引号的文字初始化。通常，必须为对象使用一种更通用的初始化类型。

2.2 所有对象都必须创建
创建句柄时，我们希望它同一个新对象连接。通常用new关键字达到这一目的。
new的意思是：“把我变成这些对象的一种新类型”。所以在上面的例子中，可以说：
String s = new String("asdf");

2.2.1 保存到什么地方
数据的保存位置：
1）寄存器 
2）堆栈 —— 保存了对象句柄（指针）
3）堆（内存池）—— 保存了Java对象
4）静态存储 —— 通过static关键字指出一个对象的特定元素是静态的，但是注意 Java对象本身永远不会置于静态存储空间
5）常数存储 —— 通常存于程序代码内部 需要严格保护的也可以置入只读存储器ROM
6）非RAM存储 —— 

2.2.2 特殊情况：基本数据类型
---boolean char byte short int long float double void
这些数据类型都不需要用new创建对象（new将对象置于“堆”中）
这些数据类型容纳了具体的值 并置于堆栈中 从而实现高效的存取
需要注意的是：Java中的数据类型不随着机器结构变化而变化，这种大小的不可更改 正是Java程序具有很强移植能力的原因之一

2.2.3 Java的数组
Java中的数组可以保证被初始化 且不可在它的范围之外访问
1）创建  对象数组  的时候，实际创建的是一个句柄数组，句柄是null 正式使用之前若未为句柄分配对象 就会报告错误
2）创建  主类型数组  的时候，编译器会保证对他的初始化 内存划分为0
由此，典型的数组错误在Java中得到了避免

2.3 绝对不要清除对象
Java如何帮助我们完成清除工作？

2.3.1 作用域 ———————— 哪些放在堆中 哪些放在栈中？—————— 一切为了垃圾收集
{
  int x = 12;
  /* only x available */
  {
    int q = 96;
    /* both x & q available */
  }
  /* only x available */
  /* q “out of scope” */
}
如下代码
这种做法在Java里是不允许的，因为Java的设计者认为这样做使程序产生了混淆。
{
  int x = 12;
  {
    int x = 96; /* illegal */
  }
}

2.3.2 对象的作用域
{
String s = new String("a string");
} /* 作用域的终点 */
那么句柄s会在作用域的终点处消失。
然而，s指向的String对象依然占据着内存空间。
在上面这段代码里，我们没有办法访问对象，
因为指向它的唯一一个句柄已超出了作用域的边界。
在后面的章节里，会继续学习如何在程序运行期间传递和复制对象句柄。 //////////////////////////significate

创建的对象一旦离开了作用域 就丢失了句柄 但是对象仍存在 如果在C++中写上述代码 就会造成“因为程序员忘记释放内存导致 —— 内存溢出 ——”
由此 引出了java中的垃圾收集器

？？？但是这里我有个问题 
如果我使用new创建一个基本数据类型会怎么样呢？那么这个基本数据类型是放在堆 还是 栈？
new的基本数据类型是放在堆还是栈？
答：堆
下面这个类A里的int a，是存放在堆还是栈(Java虚拟机栈)内存？
public class A {
    int a = 0;
    B b = new B();
}
b是对象的引用肯定是存放在堆内存，那a呢？
在java中只要是成员变量，一旦它所在类被实例化后，都是放在堆内存的，不管它是不是基础类型。
局部变量才是放在栈内存的。所以java比其他语言内存安全的多。

2.4 新建数据类型：类
每个对象都为自己的数据成员保有存储空间；数据成员不会在对象之间共享。
下面是定义了一些数据成员的类示例：
class DataOnly {
  int i;
  float f;
  boolean b;
}
这个类并没有做任何实质性的事情，但我们可创建一个对象：
DataOnly d = new DataOnly();
可将值赋给数据成员，但首先必须知道如何引用一个对象的成员。
为达到引用对象成员的目的，首先要写上对象句柄的名字，再跟随一个点号（句点），再跟随对象内部成员的名字。即“对象句柄.成员”。例如：
d.i = 47;
d.f = 1.1f;
d.b = false;
一个对象也可能包含了另一个对象，而另一个对象里则包含了我们想修改的数据。
对于这个问题，只需保持“连接句点”即可。例如：
myPlane.leftTank.capacity = 100;
除容纳数据之外，DataOnly类再也不能做更多的事情，因为它没有成员函数（方法）。
为正确理解工作原理，首先必须知道“自变量”和“返回值”的概念。我们马上就会详加解释。

2.4.1 类中主成员与局部变量的默认初始值
若某个主数据类型属于一个类成员，那么即使不明确（显式）进行初始化，也可以保证它们获得一个默认值。
默认值情况
Boolean false
Char '\u0000'(null)
byte (byte)0
short (short)0
int 0
long 0L
float 0.0f
double 0.0d
一旦将变量作为类成员使用，就要特别注意由Java分配的默认值。
这样做可保证主类型的成员变量肯定得到了初始化（C++不具备这一功能），可有效遏止多种相关的编程错误。
然而，这种保证却并不适用于“局部”变量——那些变量并非一个类的字段。 ———— 类中主成员与局部变量的默认初始值
所以，假若在一个函数定义中写入下述代码：
int x;
那么x会得到一些随机值（这与C和C++是一样的），不会自动初始化成零。
我们责任是在正式使用x前分配一个适当的值。
如果忘记，就会得到一条编译期错误，告诉我们变量可能尚未初始化。
这种处理正是Java优于C++的表现之一。许多C++编译器会对变量未初始化发出警告，但在Java里却是错误。

2.5 方法、自变量和返回值
若返回类型为void 则return关键字唯一的作用就是退出方法
！一个程序只是一系列对象的集合，他们的方法将其他对象作为自己的自变量使用，并且将消息发给那些对象

2.6 构建Java程序

2.6.1 名字的可见性
假设在程序的某个模块里使用了一个名字，另一名程序员在另一个模块里使用了相同的名字，此时该如何区分呢？C++用额外的关键字引入了“命名空间”概念
但是在Java中，全新机制避免了这些问题，实用工具库：
Java的设计者鼓励程序员反转使用自己的Internet域名，因为它们肯定是独一无二的。
由于我的域名是BruceEckel.com，所以我的实用工具库就可命名为com.bruceeckel.utility.foibles。
反转了域名后，可将点号想象成子目录。

2.6.2 使用其他组件
通过import关键字导入一个“包”或者一个“类库”

2.6.3 static关键字
Static（静态）关键字，一旦将类中的成员或函数设为static，数据或函数就不再需要类的一个对象而存在
所以尽管从未创建过那个类的一个对象，仍能调用一个static函数 或是 访问一个static数据
而对于非static数据和函数，我们必须创建一个对象，并用那个对象访问数据或是函数

为了将数据成员或方法设为static，只需在定义前置和这个关键字即可。例如，下述代码能生成一个static数据成员，并对其初始化：
class StaticTest {
Static int i = 47;
}
现在，尽管我们制作了两个StaticTest对象，但它们仍然只占据StaticTest.i的一个存储空间。
这两个对象都共享同样的i。请考察下述代码：
StaticTest st1 = new StaticTest();
StaticTest st2 = new StaticTest();
此时，无论st1.i还是st2.i都有同样的值47，因为它们引用的是同样的内存区域。
有两个办法可引用一个static变量。正如上面展示的那样，可通过一个对象命名它，如st2.i。
亦可直接用它的类名引用，而这在非静态成员里是行不通的（最好用这个办法引用static变量，因为它强调了那个变量的“静态”本质）。
StaticTest.i++;
其中，++运算符会使变量增值。此时，无论st1.i还是st2.i的值都是48。

2.7 我们的第一个Java程序
// Property.java 这是一行注释
import java.util.*;// 这是在导入类

public class Property {// 类名和文件名是一样的 文件中的一个类必须和文件同名（如果没这样做，编译器会作出反应）
  public static void main(String[] args) {// main()的自变量是包含了String对象的一个数组 args不会在本程序中用到 但需要在这个地方列出 因为它们保存了在命令行调用的自变量
    System.out.println(new Date());// 该语句一旦执行完毕 Data就不再需要 会被垃圾收集器回收
    Properties p = System.getProperties();//文档中可以找到getProperties()方法是一个static方法 所以不必创建对象 直接调用即可
    p.list(System.out);
    /*
    一些打印语句 注意加号+在不同情境下不同的表现
    */
    System.out.println("--- Memory Usage:");
    Runtime rt = Runtime.getRuntime();
    System.out.println("Total Memory = "
                       + rt.totalMemory()
                       + " Free Memory = "
                       + rt.freeMemory());
  }
}

2.8 注释和嵌入文档
有三种类型的注释文档，它们对应于位于注释后面的元素：类、变量、方法。也就是在对应位置使用对应注释 如下
/** 一个类注释 */
public class docTest {
/** 一个变量注释 */
public int i;
/** 一个方法注释 */
public void f() {}
}
有一种提取注释的工具javadoc 但是只能提取public和protected的成员注释文档 private的成员注释文档拿不到（但是所有类型的类注释还是能提取到）

2.8.4 引用其他类
@see 类名
@see 完整类名
@see 完整类名#方法名

2.8.5 类文档标记
@version 版本信息
@author 作者信息

2.8.6 变量文档标记
@see 引用

2.8.7 方法文档标记
@param 参数名 说明
@return 说明（说明的内容是返回值的含义）
@exception 完整类名 说明
@deprecated 指出一些旧功能已由改进过的新功能取代

2.8.8 文档实例
//:Properties.java
:冒号 指出了这是包含了源文件名字的一个注释行 最后一行也用这样一条注释结尾 标志着源代码清单的结束

2.9 编码样式
对于类名，大写类名中每个单词的首字母 如 
Class AllTheColorsOfRainbow { ... }
对于方法、字段、以及对象句柄名称，与类名一致，唯一不同在于标识符的第一个字母小写 如 
Class AllTheColorsOfRainbow { 
  int anIntegerRepresentingColors;
  void changeTheHueOfTheColor(int newHue){
    ...
  }
}

2.10 总结

2.11 练习
(1) 参照本章的第一个例子，创建一个“Hello，World”程序，在屏幕上简单地显示这句话。注意在自己的类里只需一个方法（“main”方法会在程序启动时执行）。记住要把它设为static形式，并置入自变量列表——即使根本不会用到这个列表。用javac编译这个程序，再用java运行它。
public InputHelloWorld {
  public static void main (String[] args) {
    System.out.println ("Hello, world");
  }
}

(2) 写一个程序，打印出从命令行获取的三个自变量。

(3) 找出Property.java第二个版本的代码，这是一个简单的注释文档示例。请对文件执行javadoc，并在自己的Web浏览器里观看结果。

(4) 以练习(1)的程序为基础，向其中加入注释文档。利用javadoc，将这个注释文档提取为一个HTML文件，并用Web浏览器观看。

