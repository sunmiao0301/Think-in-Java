## Think in java

#### 其实这本书还是适合有一些企业级开发经验之后再读，对于基础，更好的是《Core Java Volume Ⅰ——Fundamentals》

| 章节                                                         | 备注                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1 对象入门                                                   |                                                              |
| 1.1 抽象的进步                                               |                                                              |
| 1.2 对象的接口（方法）                                       |                                                              |
| 1.3 实现方案的隐藏                                           | 方案：访问控制                                               |
| 1.4 方案的重复使用                                           | 组织 —— 为重复使用一个类，最简单的办法是仅直接使用那个类的对象。但同时也能将那个类的一个对象置入一个新类。 |
| 1.5 继承：重新使用接口（方法）                               | 在Java中，继承是通过extends关键字实现的，使用继承时，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员（尽管private成员被隐藏起来，且不能访问），但更重要的是，它复制了父类的方法。<br>但是子类的对象不仅有和父类相同的类型，也有同样的行为，这一后果通常是我们不愿见到的。<br>对此，有两种做法可将新得的子类与原来的父类区分开。第一种做法十分简单：为衍生类添加新函数（功能）。第二个办法是改变基础类一个现有函数的行为。我们将其称作“重写”那个函数。 |
| 1.6 多形对象的互换使用                                       | 比如父类是Shape，且有一个函数需要Shape对象作为参数`void doStuff(Shape s)`，那么对于Shape的子类Circle的一个对象`Circle c = new Circle()`，我们也可以对其调用`doStuff(c)`，是安全的，不会错误，我们将这种把子类当作它的父类处理的过程叫作“Upcasting”（上溯造型），这是怎么做到的呢？<br>将一条消息发给对象时，如果并不知道对方的具体类型是什么，但采取的行动同样是正确的，这种情况就叫作“多态性”（Polymorphism）。面向对象的程序设计语言，它们用以实现多态性的方法叫作“动态绑定”。编译器和运行期系统会负责对所有细节的控制；我们只需知道会发生什么事情，而且更重要的是，如何利用它帮助自己设计程序。<br>设计程序时，我们经常都希望父类只为自己的衍生类提供一个接口。也就是说，我们不想其他任何人实际创建父类的一个对象，只对上溯造型成它，以便使用它们的接口。为达到这个目的，需要把那个类变成“抽象”的——使用abstract关键字。若有人试图创建抽象类的一个对象，编译器就会阻止他们。这种工具可有效强制实行一种特殊的设计。<br>interface（接口）关键字将抽象类的概念更延伸了一步，它完全禁止了所有的函数定义。“接口”是一种相当有效和常用的工具。另外如果自己愿意，亦可对多个接口继承（但是类不支持多继承） |
| 1.7 对象的创建和存在时间                                     | 对象的创建及破坏方式：C++将对象放置在堆栈（有时也叫作自动或定域变量）或者静态存储区域，这种方法在编写程序时，必须知道对象的准确的数量、存在时间、以及类型。<br>第二个方法是在一个内存池中动态创建对象，该内存池亦叫“堆”或者“内存堆”。若采用这种方式，除非进入运行期，否则根本不知道到底需要多少个对象，也不知道它们的存在时间有多长，以及准确的类型是什么。这些参数都在程序正式运行时才决定的。若需一个新对象，只需在需要它的时候在内存堆里简单地创建它即可<br>Java垃圾收集器 —— 这意味着在Java程序执行期间，存在着一种不连贯的因素。所以在某些特殊的场合，我们必须避免用它<br>如果想对集合中的一系列元素进行操纵或比较，而不是仅仅面向一个，这时又该怎么办呢？办法就是使用一个“迭代器”（Iterator）<br>单根结构：Java中，所有类最终都从单独一个父类“Object”继承。这种“单根结构”具有许多方面的优点：<br>1）保证所有对象都拥有一些特定功能<br>2）单根结构，加上所有对象都在内存堆中创建，极大简化参数的传递<br>3）方便地实现一个垃圾收集器<br>p.s.C++没有选择单根结构<br>下溯造型，我们很难保证下溯造型的安全进行，除非确切地知道自己要操作的是什么。<br> |
| 1.8 违例控制：解决错误                                       | Exception —— Java的违例控制机制与大多数程序设计语言都有所不同。因为在Java中，违例控制模块是从一开始就封装好的，所以必须使用它！ |
| 1.9 多线程                                                   | 注意“共享资源”问题：Java的多线程机制已内建到语言中，对多线程处理的支持是在对象这一级支持的，所以一个执行线程可表达为一个对象。<br>Java也提供了有限的资源锁定方案。它能锁定任何对象占用的内存（内存实际是多种共享资源的一种），所以同一时间只能有一个线程使用特定的内存空间。为达到这个目的，需要使用synchronized关键字。其他类型的资源必须由程序员明确锁定，这通常要求程序员创建一个对象，用它代表一把锁，所有线程在访问那个资源时都必须检查这把锁。 |
| 1.10 永久性                                                  | 可将对象简单地保存到磁盘上，以后任何时间都可取回。           |
| *1.11 Java和因特网                                           | **[LINK](https://books.didispace.com/think-in-java/1.11%20Java%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91.html)** |
| 1.12 分析和设计                                              | 面向对象范式                                                 |
| 1.13 Java还是C++                                             | 相比C++，Java开发起来快，但是跑起来慢。—— （有人建议在开发期间使用Java，以缩短开发时间。然后用一个工具和支撑库将代码转换成C++，这样可获得更快的执行速度） |
|                                                              |                                                              |
| 2 一切都是对象                                               | C++支持与C语言的向后兼容能力，其中的某些特性使得C++过于复杂，Java则不必考虑这些，相对易学易用 |
| 2.1 用句柄操作对象                                           | 句柄（Handle） —— 实际上就是Java中我们常说的：对对象的引用，如`String s;`就是创建了一个String句柄，但这里创建的只是句柄，并不是对象。若此时向s发送一条消息，就会获得一个错误（运行期）。这是由于s实际并未与任何东西连接。因此，一种更安全的做法是：创建一个句柄时，记住无论如何都进行初始化：`String s = "asdf";` |
| 2.2 所有对象都必须创建                                       | 创建句柄时，我们希望它同一个新对象连接。通常用new关键字达到这一目的。<br>`String s = new String("asdf");` |
| 2.3 绝对不要清除对象                                         | Java中，基本数据类型是处在`{...}`作用域之内的：<br>{   <br>    int x = 12;   // only x available   <br/>    {     <br/>        int q = 96;     // both x & q available   <br/>    }   <br/>// only x available  <br/>// q “out of scope” <br/>}<br/><br/>Java对象不具备与基本数据类型一样的存在时间。用new关键字创建一个Java对象的时候，它会超出作用域的范围之外：<br>{ <br/>String s = new String("a string"); <br/>} // 作用域的终点 <br/><br/>很面明显，句柄s会在作用域的终点处消失。然而，s指向的String对象依然占据着内存空间。在上面这段代码里，我们没有办法访问对象，因为指向它的唯一一个句柄已超出了作用域的边界。<br/>正因为如此，Java中的垃圾收集器很关键。 |
| 2.4 新建数据类型：类                                         | 可在自己的类里设置两种类型的元素：数据成员（有时也叫“字段”）以及成员函数（通常叫“方法”）；每个对象都为自己的数据成员保有存储空间；数据成员不会在对象之间共享。<br><br>若某个基本数据类型属于一个类的字段，那么即使不明确（显式）进行初始化，也可以保证它们获得一个默认值。然而，这种保证却并不适用于“局部”变量——那些变量并非一个类的字段。所以，假若在一个函数定义中写入下述代码：`int x;`，那么x会得到一些随机值（这与C和C++是一样的），不会自动初始化成零。 |
| 2.5 方法、自变量和返回值                                     | Java的方法只能作为类的一部分创建。只能针对某个对象调用一个方法（注释③）<br>③：正如马上就要学到的那样，“静态”方法可针对类调用，毋需一个对象。<br><br>若返回类型为void，则return关键字唯一的作用就是退出方法。所以一旦抵达方法末尾，该关键字便不需要了。可在任何地方从一个方法返回。 |
| *2.6 构建Java程序                                            | 包 —— Java的这种特殊机制意味着所有文件都自动存在于自己的命名空间里，而且一个文件里的每个类都自动获得一个独一无二的标识符（当然，一个文件里的类名必须是唯一的）<br><br>2.6.3 **[static关键字](https://books.didispace.com/think-in-java/2.6%20%E6%9E%84%E5%BB%BAJava%E7%A8%8B%E5%BA%8F.html)**<br>通常，我们创建类时会指出那个类的对象的外观与行为。除非用new创建那个类的一个对象，否则实际上并未得到任何东西。只有执行了new后，才会正式生成数据存储空间，并可使用相应的方法。<br>但在两种特殊的情形下，上述方法并不堪用。一种情形是只想用一个存储区域来保存一个特定的数据——无论要创建多少个对象，甚至根本不创建对象。另一种情形是我们需要一个特殊的方法，它没有与这个类的任何对象关联。也就是说，即使没有创建对象，也需要一个能调用的方法。为满足这两方面的要求，可使用static（静态）关键字。一旦将什么东西设为static，数据或方法就不会同那个类的任何对象实例联系到一起。所以尽管从未创建那个类的一个对象，仍能调用一个static方法，或访问一些static数据。而在这之前，对于非static数据和方法，我们必须创建一个对象，并用那个对象访问数据或方法。这是由于非static数据和方法必须知道它们操作的具体对象。当然，在正式使用前，由于static方法不需要创建任何对象，所以它们不可简单地调用其他那些成员，同时不引用一个已命名的对象，从而直接访问非static成员或方法（因为非static成员和方法必须同一个特定的对象关联到一起）。 有些面向对象的语言使用了“类数据”和“类方法”这两个术语。它们意味着数据和方法只是为作为一个整体的类而存在的，并不是为那个类的任何特定对象。有时，您会在其他一些Java书刊里发现这样的称呼。<br>为了将数据成员或方法设为static，只需在定义前置和这个关键字即可。例如，下述代码能生成一个static数据成员，并对其初始化：<br>`class StaticTest { Static int i = 47; }`<br>`StaticTest st1 = new StaticTest();` <br>`StaticTest st2 = new StaticTest();`<br>现在，尽管我们制作了两个StaticTest对象，但它们仍然只占据StaticTest.i的一个存储空间。这两个对象都共享同样的i。此时，无论st1.i还是st2.i都有同样的值47，因为它们引用的是同样的内存区域。<br>有两个办法可引用一个static变量。正如上面展示的那样：<br>1）可通过一个对象命名它，如st2.i。<br>2）亦可直接用它的类名引用，而这在非静态成员里是行不通的（最好用这个办法引用static变量，因为它强调了那个变量的“静态”本质）。<br><br>static一项重要的用途就是帮助我们在不必创建对象的前提下调用那个方法。正如以后会看到的那样，这一点是至关重要的——特别是在定义程序运行入口方法main()的时候。 |
| 2.7 我们的第一个Java程序                                     | `public static void main(String[] args) {}`<br>其中，关键字“public”意味着方法可由外部世界调用（第5章会详细解释）。main()的自变量是包含了String对象的一个数组。args不会在本程序中用到，但需要在这个地方列出，因为它们保存了在命令行调用的自变量。 |
| 2.8 注释和嵌入文档                                           | **[2.8 注释和嵌入文档](https://books.didispace.com/think-in-java/2.8%20%E6%B3%A8%E9%87%8A%E5%92%8C%E5%B5%8C%E5%85%A5%E6%96%87%E6%A1%A3.html)** |
| 2.9 编码样式                                                 |                                                              |
| 2.10 总结                                                    |                                                              |
|                                                              |                                                              |
| 3.控制程序流程                                               |                                                              |
| 3.1 使用Java运算符                                           | 赋值操作<br>对主数据类型的赋值是非常直接的。由于主类型容纳了实际的值，而且并非指向一个对象的句柄，所以在为其赋值的时候，可将来自一个地方的内容复制到另一个地方。<br>但在为对象“赋值”的时候，情况却发生了变化。对一个对象进行操作时，我们真正操作的是它的句柄。所以倘若“从一个对象到另一个对象”赋值，实际就是将句柄从一个地方复制到另一个地方。这意味着假若为对象使用“C=D”，那么C和D最终都会指向最初只有D才指向的那个对象。<br><br>在许多程序设计语言中，f(Letter y)方法表面上似乎要在方法的作用域内制作自己的自变量Letter y的一个副本。但同样地，实际传递的是一个句柄。<br><br>算数运算符<br>整数除法会直接砍掉小数，而不是进位。<br/><br/>关系运算符—比较<br>== 和 equals<br/><br/>逻辑运算符—短路<br/><br/>按位运算符<br/><br/>移位运算符—有符号移位>> 无符号移位>>><br><br>在C和C++中，sizeof()运算符能满足我们的一项特殊需要：获知为数据项目分配的字符数量。Java不需要sizeof()运算符来满足这方面的需要，因为所有数据类型在所有机器的大小都是相同的。我们不必考虑移植问题——Java本身就是一种“与平台无关”的语言。 |
| 3.2 执行控制                                                 | Java里唯一用到逗号运算符的地方就是for循环的控制表达式。<br>`Switch` |
| 3.3 总结                                                     |                                                              |
|                                                              |                                                              |
| 4 初始化和清除                                               | “初始化”和“清除”是这些安全问题的其中两个。许多C程序的错误都是由于程序员忘记初始化一个变量造成的。对于现成的库，若用户不知道如何初始化库的一个组件，就往往会出现这一类的错误。清除是另一个特殊的问题，因为用完一个元素后，由于不再关心，所以很容易把它忘记。这样一来，那个元素占用的资源会一直保留下去，极易产生资源（主要是内存）用尽的后果。 |
| 4.1 用构建器自动初始化                                       | 构建器属于一种较特殊的方法类型，因为它没有返回值。这与void返回值存在着明显的区别。对于void返回值，尽管方法本身不会自动返回什么，但仍然可以让它返回另一些东西。构建器则不同，它不仅什么也不会自动返回，而且根本不能有任何选择。若存在一个返回值，而且假设我们可以自行选择返回内容，那么编译器多少要知道如何对那个返回值作什么样的处理。 |
| 4.2 方法过载                                                 | **在Java里，另一项因素强迫方法名出现重载情况：构建器。由于构建器的名字由类名决定，所以只能有一个构建器名称。**但假若我们想用多种方式创建一个对象呢？例如，假设我们想创建一个类，令其用标准方式进行初始化，另外从文件里读取信息来初始化。此时，我们需要两个构建器，一个没有自变量（默认构建器），另一个将字串作为自变量——用于初始化对象的那个文件的名字。由于都是构建器，所以它们必须有相同的名字，亦即类名。所以为了让相同的方法名伴随不同的自变量类型使用，“方法过载”是非常关键的一项措施。同时，尽管方法过载是构建器必需的，但它亦可应用于其他任何方法，且用法非常方便。<br><br/>自变量的顺序也足够我们区分两个方法，比如`void print(int i, String s)`和`void print(int i, String s)`（尽管我们通常不愿意采用这种方法，因为它会产生难以维护的代码）<br><br/>不能根据返回值类型来区分过载的方法。<br/><br>基本数据类型的重载，能从一个“较小”的类型自动转变成一个“较大”的类型。 若我们的自变量“大于”过载方法期望的自变量，这时又会出现什么情况呢？若我们的自变量范围比它宽，就必须用括号中的类型名将其转为适当的类型。如果不这样做，编译器会报告出错。大家可注意到这是一种“缩小转换”。也就是说，在造型或转型过程中可能丢失一些信息。这正是编译器强迫我们明确定义的原因——我们需明确表达想要转型的愿望，比如对于方法：<br/>public static double add(int i, double d){<br/>     return i + d; <br/>}<br/><br/>我们运行如下代码：<br/>int i = 1; <br/>double d = 2.0;<br/>System.out.println(add(i, d));//没问题<br/>System.out.println(add(i, i));//没问题<br/>System.out.println(add(d, d));//报错<br/><br/>当我们没有自己定义构造函数，那么编译程序将帮我们自动构建一个默认无参构造函数。但当我们已经定义了构造函数，编译程序就不会帮我们自动合成一个无参构造函数，此时如果再调用无参构造函数，就会报错：<br><br>假定我们在一个方法的内部，并希望获得当前对象的句柄。针对这一目的有个专用的关键字：this；**但要注意，假若准备从自己某个类的另一个方法内部调用一个类方法，就不必使用this。只需简单地调用那个方法即可。当前的this句柄会自动应用于其他方法。**this的另一项用途。由于自变量s的名字以及成员数据s的名字是相同的，所以会出现混淆。为解决这个问题，可用this.s来引用成员数据。经常都会在Java代码里看到这种形式的应用，本书的大量地方也采用了这种做法。 |
| *4.3 清除：收尾和垃圾收集                                    |                                                              |
| * **[4.4 成员初始化-比较复杂](https://books.didispace.com/think-in-java/4.4%20%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96.html)** | 对于一个类，如果你对其中的字段都不进行初始化，那么字段中的所有基本类型数据成员都会保证获得一个初始值（0，false等）。在一个类的内部定义一个对象句柄时，如果不将其初始化成新对象，那个句柄就会获得一个空值NULL。<br><br>初始化比较常见的方法是：<br>1）最直接的做法是在类内部定义变量的同时也为其赋值<br>class Measurement {<br>   boolean b = true;<br/>   Depth d = new Depth();<br>}<br/>2）通过构造函数初始化<br>class Counter {<br/>   int i; <br/>   Counter() { i = 7; }<br/>}<br/>3）对每个字段，即在定义时初始化，也在构造函数调用时；<br>从表面看，这样做似乎效率低下，但它能保证正确的初始化——若定义了一个过载的构建器，它没有初始化t3；同时在t3的定义里并没有规定“默认”的初始化方式，可能会造成严重后果。<br><br>其余比较复杂部分见4.4链接。 |
| 4.5 数组初始化                                               | 注意，我们拥有的一切就是指向数组的一个句柄，`int[] a;`给我们的是一个数组对象的句柄（引用）<br>多维数组 |
| 4.6 总结                                                     |                                                              |
| 5 隐藏实施过程                                               | Java访问控制                                                 |
| *5.1 包：库单元                                              | 之所以要进行这样的导入，是为了提供一种特殊的机制，以便管理“命名空间”（Name Space）。我们所有类成员的名字相互间都会隔离起来。位于类A内的一个方法f()不会与位于类B内的、拥有相同“签名”（自变量列表）的f()发生冲突。但类名会不会冲突呢？假设创建一个stack类，将它安装到已有一个stack类（由其他人编写）的机器上，这时会出现什么情况呢？对于因特网中的Java应用，这种情况会在用户毫不知晓的时候发生，因为类会在运行一个Java程序的时候自动下载。<br>每个编译单元都必须有一个以.java结尾的名字。而且在编译单元的内部，可以有一个公共（public）类，它必须拥有与文件相同的名字（包括大小写形式，但排除.java文件扩展名）。如果不这样做，编译器就会报告出错。每个编译单元内都只能有一个public类（同样地，否则编译器会报告出错）。那个编译单元剩下的类（如果有的话）可在那个包外面的世界面前隐藏起来，因为它们并非“公共”的（非public），而且它们由用于主public类的“支撑”类组成。<br><br>如决定发行自己的Java代码，那么强烈推荐去申请自己的域名，它所需的费用是非常低廉的。<br/><br/>自定义工具库 |
| 5.2 Java访问指示符                                           | public > protected > default > private                       |
| 5.3 接口与实现                                               |                                                              |
| 5.4 类访问                                                   | **每个编译单元（文件）都只能有一个public类。每个编译单元有一个公共接口的概念是由那个公共类表达出来的。根据自己的需要，它可拥有任意多个提供支撑的“友好”类。**<br>可能（但并常见）有一个编译单元根本没有任何公共类。此时，可按自己的意愿任意指定文件名。<br><br/>若自己编写默认构建器，它就不会自动创建。把它变成private后，就没人能为那个类创建一个对象。但别人怎样使用这个类呢？<br>1）第一个选择，我们可创建一个static方法，再通过它创建一个新的Soup，然后返回指向它的一个句柄。如果想在返回之前对Soup进行一些额外的操作，或者想了解准备创建多少个Soup对象（可能是为了限制它们的个数），这种方案无疑是特别有用的。<br>2）第二个选择是采用“设计模式”（Design Pattern）技术 |
| 5.5 总结                                                     | 有两方面的原因要求我们控制对成员的访问。<br/>1）防止用户接触那些他们不应碰的工具。<br/>2）允许库设计者改变类的内部工作机制，同时不必担心它会对客户程序员产生什么影响。 |
|                                                              |                                                              |
| 6 类再生                                                     | 1）第一个最简单：在新类里简单地创建原有类的对象。我们把这种方法叫作“合成”，因为新类由现有类的对象合并而成。我们只是简单地重复利用代码的功能，而不是采用它的形式。<br/>2）第二种方法则显得稍微有些技巧。它创建一个新类，将其作为现有类的一个“类型”。我们可以原样采取现有类的形式，并在其中加入新代码，同时不会对现有的类产生影响。这种魔术般的行为叫作“继承”（Inheritance） |
| 6.1 合成的语法                                               | 为进行合成，我们只需在新类里简单地置入对象句柄即可。<br>p.s. 每个引用类型的对象都有一个toString()方法，。若编译器本来希望一个String，但却获得某个这样的对象，就会调用这个方法。 |
| **[6.2 继承的语法](https://books.didispace.com/think-in-java/6.2%20%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AF%AD%E6%B3%95.html)** | extends可自动获得基础类的所有数据成员以及方法。<br><br>一个java函数中能有多个class，但只能有一个public class。<br><br>需要着重强调的是Cleanser中的所有内容都是public属性。请记住，倘若省略所有访问指示符，则成员默认为“友好的”。这样一来，就只允许对包成员进行访问。在这个包内，任何人都可使用那些没有访问指示符的方法。例如，Detergent将不会遇到任何麻烦。然而，假设来自另外某个包的类准备继承Cleanser，它就只能访问那些public成员。所以在计划继承的时候，一个比较好的规则是将所有字段都设为private，并将所有方法都设为public（protected成员也允许衍生出来的类访问它；以后还会深入探讨这一问题）。当然，在一些特殊的场合，我们仍然必须作出一些调整，但这并不是一个好的做法。<br><br>我们通常想在新版本里调用来自基础类的方法func()。**但在子类的func()里，不可只是简单地发出对func()的调用。那样便造成了递归调用，我们不愿看到这一情况。**为解决这个问题，Java提供了一个super关键字，它引用当前类已从中继承的一个“超类”（Superclass）。所以表达式super.func()调用的是方法scrub()的基础类版本。<br><br>在子类的默认构造函数中，Java会自动插入对父类默认构造函数的调用。<br>但若想调用含有一个自变量的某个父类构造函数，必须明确地编写对父类的调用代码，这是用super关键字以及适当的自变量列表实现的：<br>class Game {<br/>   Game(int i) {<br/>     System.out.println("Game constructor");<br/>   }<br/> }  <br/>class BoardGame extends Game {<br/>   BoardGame(int i) {<br/>     super(i);<br/>     System.out.println("BoardGame constructor");<br/>   }<br/> }<br/>除此以外，在子类构造函数中，对父类构造函数的调用是必须做的第一件事情。 |
| 6.3 合成与继承的结合                                         | 两个新关键词：try和finally<br>在Java中，清除可能并不是个问题；只需让垃圾收集器尽它的职责即可。但一旦必须由自己明确清除，就必须特别谨慎，并要求周全的考虑。<br>**名字的隐藏** |
| 6.4 到底选择合成还是继承                                     | “属于”关系是用继承来表达的，而“包含”关系是用合成来表达的。比如，我们不能用一个车辆对象来合成一辆汽车——汽车并不“包含”车辆；相反，它“属于”车辆的一种类别 |
| 6.5 protected                                                | protected关键字的意思是“它本身是私有的，但可由从不同包的子类或者同一个包内的子类和非子类访问”。我们采取的最好的做法是保持成员的private状态——无论如何都应保留对基础的实施细节进行修改的权利。在这一前提下，可通过protected方法允许类的继承者进行受到控制的访问：<br>class Villain {<br/>   private int i;<br/>   protected void set(int ii) { i = ii; } <br/>}  <br/>public class Orc extends Villain {<br/>   public void change(int x) { set(x); } <br/>} |
| 6.6 累计开发                                                 | 继承的一个好处是它支持“累积开发”，允许我们引入新的代码，同时不会为现有代码造成错误。这样可将新错误隔离到新代码里。通过从一个现成的、功能性的类继承，同时增添成员新的数据成员及方法（并重新定义现有方法），我们可保持现有代码原封不动（另外有人也许仍在使用它），不会为其引入自己的编程错误。一旦出现错误，就知道它肯定是由于自己的新代码造成的。这样一来，与修改现有代码的主体相比，改正错误所需的时间和精力就可以少很多。<br>类的隔离效果非常好，这是许多程序员事先没有预料到的。甚至不需要方法的源代码来实现代码的再生。最多只需要导入一个包（这对于继承和合并都是成立的）。大家要记住这样一个重点：程序开发是一个不断递增或者累积的过程，就象人们学习知识一样。当然可根据要求进行尽可能多的分析，但在一个项目的设计之初，谁都不可能提前获知所有的答案。如果能将自己的项目看作一个有机的、能不断进步的生物，从而不断地发展和改进它，就有望获得更大的成功以及更直接的反馈。<br>尽管继承是一种非常有用的技术，但在某些情况下，特别是在项目稳定下来以后，仍然需要从新的角度考察自己的类结构，将其收缩成一个更灵活的结构。请记住，继承是对一种特殊关系的表达，意味着“这个新类属于那个旧类的一种类型”。我们的程序不应纠缠于一些细树末节，而应着眼于创建和操作各种类型的对象，用它们表达出来自“问题空间”的一个模型。 |
| 6.7 上溯造型                                                 | 为什么叫做“上溯造型”？之所以叫作这个名字，除了有一定的历史原因外，也是由于在传统意义上，类继承图的画法是根位于最顶部，再逐渐向下扩展。所以上溯就是apple被Upcasting为fruit。上溯造型肯定是安全的。<br><br>为判断自己到底应该选用合成还是继承，一个最简单的办法就是考虑是否需要从新类上溯造型回基础类。若必须上溯，就需要继承。但如果不需要上溯造型，就应提醒自己防止继承的滥用。在下一章里（多形性），会向大家介绍必须进行上溯造型的一种场合。但只要记住经常问自己“我真的需要上溯造型吗”，对于合成还是继承的选择就不应该是个太大的问题。 |
| **[6.8 final关键字](https://books.didispace.com/think-in-java/6.8%20final%E5%85%B3%E9%94%AE%E5%AD%97.html)** | final关键字的三种应用场合：数据、方法以及类。<br>final和static |
| 6.9 初始化和类装载                                           | Java中的一切东西都是对象，所以许多活动变得更加简单，这个问题便是其中的一例。正如下一章会讲到的那样，每个对象的代码都存在于独立的文件中。除非真的需要代码，否则那个文件是不会载入的。通常，我们可认为除非那个类的一个对象构造完毕，否则代码不会真的载入。由于static方法存在一些细微的歧义，所以也能认为“类代码在首次使用的时候载入”。 |
| 6.10 总结                                                    |                                                              |
|                                                              |                                                              |
| 7 多形性（多态）                                             | “对于面向对象的程序设计语言，多态是第三种最基本的特征（前两种是抽象和继承）。”<Br>通过上一章的学习，大家已知道通过继承可将一个对象当作它自己的类型或者它自己的基础类型对待。这种能力是十分重要的，因为多个类型（从相同的基础类型中衍生出来）可被当作同一种类型对待。而且只需一段代码，即可对所有不同的类型进行同样的处理。<br>在这一章中，大家要由浅入深地学习有关多形性的问题（也叫作动态绑定、推迟绑定或者运行期绑定） |
| 7.1 上溯造型                                                 | 取得一个对象句柄，并将其作为父类句柄使用的行为就叫作“上溯造型”<br>为什么要上溯造型?<br/>为什么有意忘记一个对象的类型呢？而且如果让drop()简单地取得一个Apple句柄，将其作为自己的自变量使用，似乎会更加简单、直观得多。但要注意：假如那样做，就需为Fruit的每种子类型写一个全新的drop()。<br>这正是“多态”大显身手的地方。然而，大多数程序员（特别是有程序化编程背景的）对于多态的工作原理仍然显得有些生疏。 |
| 7.2 深入理解                                                 | 对于public static void drop(Fruit f) {<br>    ...<br>}<br>当我们使用上溯转型的时候，编译器怎样才能知道Fruit句柄指向的是一个Apple，而不是一个Banana或Pear呢？编译器无从得知。为了深入了理解这个问题，我们有必要探讨一下“绑定”这个主题。<br>解决的方法就是“后期绑定”，它意味着绑定在运行期间进行，以对象的类型为基础。后期绑定也叫作“动态绑定”或“运行期绑定”。若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。**但我们可以这样认为：尽管不同语言的动态绑定实现方法不同，但是相同的是它们都要在对象中安插某些特殊类型的信息。**<br>Java中绑定的所有方法都采用后期绑定技术，这意味着我们通常不必决定是否应进行后期绑定——它是自动发生的。<br>除非一个方法已被声明成final。为什么要把一个方法声明成final呢？正如上一章指出的那样，它能防止其他人覆盖那个方法。但也许更重要的一点是，它可有效地“关闭”动态绑定，或者告诉编译器不需要进行动态绑定。这样一来，编译器就可为final方法调用生成效率更高的代码。<br><br>上溯造型可用下面这个语句简单地表现出来：<br>Shape s = new Circle();<br>在这里，我们创建了Circle对象，并将结果句柄立即赋给一个Shape。这表面看起来似乎属于错误操作（将一种类型分配给另一个），但实际是完全可行的——因为按照继承关系，Circle属于Shape的一种。因此编译器认可上述语句，不会向我们提示一条出错消息。 当我们调用其中一个基础类方法时（已在衍生类里覆盖）：<br>s.draw();<br>同样地，大家也许认为会调用Shape的draw()，因为这毕竟是一个Shape句柄。那么编译器怎样才能知道该做其他任何事情呢？但此时实际调用的是Circle.draw()，因为后期绑定已经介入（多形性）。 |
| 7.3 （覆盖和过载）重写和重载                                 | 重写检查动态类型；重载检查静态类型                           |
| 7.4 抽象类和方法                                             | 针对这个问题，Java专门提供了一种机制，名为“抽象方法”。它属于一种不完整的方法，只含有一个声明，没有方法主体。下面是抽象方法声明时采用的语法：<br>abstract void X();<br>包含了抽象方法的一个类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）。否则，编译器会向我们报告一条出错消息。<br>因为方法不完整，那么一旦有人试图生成那个类的一个对象，编译器又会采取什么行动呢？由于不能安全地为一个抽象类创建属于它的对象，所以会从编译器那里获得一条出错提示。**通过这种方法，我们就不必再担心会误用它。**<br>如果从一个抽象类继承，而且想生成新类型的一个对象，就必须为基础类中的所有抽象方法提供方法定义。如果不这样做（完全可以选择不做），则衍生类也会是抽象的，而且编译器会强迫我们用abstract关键字标志那个类的“抽象”本质。<br>![](https://raw.githubusercontent.com/sunmiao0301/Public-Pic-Bed/main/0220abstract.png) |
| 7.5 接口                                                     | “interface”（接口）关键字使抽象的概念更深入了一层。我们可将其想象为一个“纯纯的”抽象类。它允许创建者规定一个类的基本形式：方法名、自变量列表以及返回类型，但不规定方法主体。接口也包含了基本数据类型的数据成员，但它们都默认为static和final。接口只提供一种形式，并不提供实施的细节。<br>在实现一个接口的时候，来自接口的方法必须定义成public（但即使不明确定义，也会默认为public）。否则如果和类中一样的话，它们会默认为“友好的”，而且会限制我们在继承过程中对一个方法的访问——Java编译器不允许我们那样做。<br>接口可以多“实现”，可根据需要使用多个接口，而且每个接口都会成为一个独立的类型，可对其进行上溯造型，也就是说子类可以上溯造型为父接口中的任何一个。这也是使用接口最重要的一个原因：能上溯造型至多个基础类。<br>几个接口可以被类多继承，也可以被接口多继承：<br>interface Monster {}<br>interface DangerousMonster extends Monster {}![](https://raw.githubusercontent.com/sunmiao0301/Public-Pic-Bed/main/0220interface.png) |
| p.s.                                                         | 到底应该使用一个接口还是一个抽象类呢？<br>事实上，如果事先知道某种东西会成为基础类，那么第一个选择就是把它变成一个接口。只有在必须使用方法定义（java8中default打破了）或者成员**变量（接口默认字段是public static final的）**的时候，才应考虑采用抽象类。—— 对于抽象类和接口之间的选择，这涉及比较深的思想了，先放着，一般情况下接口，足矣。 |
| ***[7.6 内部类](https://books.didispace.com/think-in-java/7.6%20%E5%86%85%E9%83%A8%E7%B1%BB.html)** |                                                              |
| *7.7 构建器和多形性                                          | **构建器调用的分级结构（顺序）**<br>**继承和finalize()**     |
| 7.8 通过继承进行设计                                         | 上溯类型也有一个缺点：衍生类中对接口扩展的那一部分不可在基础类中使用。所以一旦上溯造型，就不可再调用新方法<br>下溯造型与运行期类型标识：<br>在Java中，所有造型都会自动得到检查和核实！所以即使我们只是进行一次普通的括弧造型，进入运行期以后，仍然会毫无留情地对这个造型进行检查，保证它的确是我们希望的那种类型。如果不是，就会得到一个ClassCastException（类造型违例）。在运行期间对类型进行检查的行为叫作“运行期类型标识”（RTTI）。 |
| 7.9 总结                                                     |                                                              |
|                                                              |                                                              |
| 8 对象的容纳                                                 |                                                              |
| 8.1 数组                                                     |                                                              |
| 8.2 集合                                                     | 集合实际容纳的是类型为Object的一些对象的句柄。这种类型当然代表Java中的所有对象，因为它是所有类的根。**当然，也要注意这并不包括基本数据类型，因为它们并不是从“任何东西”继承来的。**<br>Vector 略 |
| 8.3 迭代器                                                   | “迭代器”（Iterator）的概念达到这个目的。它可以是一个对象，作用是遍历一系列对象，并选择那个序列中的每个对象，同时不让客户程序员知道或关注那个序列的基础结构。 |
| 8.4 集合的类型                                               | Vector 略<br>BitSet 略<br/>Stack<br/>HashMap：<br/>所有对象都有一个散列码，而hashCode()是根类Object的一个方法。Hashtable通过hashCode()获得对象的散列值，然后用它快速查找Key。<br>所有集合能容纳的仅有对象句柄，所以根本不可以使用基本数据类型。学过集合后，封装类的概念对大家来说就可能更容易理解了。<br>equals()和hashCode()：<br>如果我们用一个标准库的类（Integer）作为Hashtable的一个键使用，它能很好地工作，因为它已经具备正确运行的所有条件。但在使用散列表的时候，一旦我们创建自己的类作为键使用，就会遇到一个很常见的问题：比如我们对一个People的种族作为键，身高作为值，进行在散列表中的填充。<br>看起来似乎非常简单，但实际是不可行的。问题在于People是从通用的Object根类继承的（若当初未指定基础类，则所有类最终都是从Object继承的）。**事实上是用Object的hashCode()方法生成每个对象的散列码，而且默认情况下只使用它的对象的地址。而两个对象不可能有相同的地址**。所以，哪怕People1是中国人，People2也是中国人，它们属于一个种族，应该有相同的散列值，但是事实将不是如此。大家或许认为此时要做的全部事情就是正确地覆盖hashCode()。但这样做依然行不能，除非再做另一件事情：覆盖也属于Object一部分的equals()。当散列表试图判断我们的键是否等于表内的某个键时，就会用到这个方法。同样地，默认的Object.equals()只是简单地比较对象地址，所以一个中国人People1并不等于另一个中国人People2。<br>因此，为了在散列表中将自己的类作为键使用，必须同时覆盖hashCode()和equals()。<br>当迭代器需要得到集合中的内容的String，它会利用这些集合中的对象属于Object类这一事实，进而调用toString()。 |
| 8.5 排序                                                     |                                                              |
| 8.6 通用集合库                                               |                                                              |
| 8.7 新集合                                                   | Java 1.2 的例子，太老了![img](https://books.didispace.com/think-in-java/8-1.gif) |
| 8.8 总结                                                     |                                                              |
|                                                              |                                                              |
| *9 违例差错控制                                              | Java的基本原理就是“形式错误的代码不会运行”。<br>**p.s. 使用较少，这一章暂时不太理解** |
| 9.1 基本违例                                                 | 为什么需要违例控制？<br>一个简单的例子是“除法”。如可能被零除，就有必要进行检查，确保程序不会冒进，并在那种情况下执行除法。但具体通过什么知道分母是零呢？在那个特定的方法里，在我们试图解决的那个问题的环境中，我们或许知道该如何对待一个零分母。但假如它是一个没有预料到的值，就不能对其进行处理，所以必须产生一个违例，而非不顾一切地继续执行下去。 |
| *9.2 违例的捕获                                              | try {<br/>   // Code that might generate exceptions <br/>} catch(Type1 id1) {   <br/>// Handle exceptions of Type1 <br/>} catch(Type2 id2) {<br/>   // Handle exceptions of Type2 <br/>}<br><br>违例规范采用了一个额外的关键字：throws；后面跟随全部潜在的违例类型。因此，我们的方法定义看起来应象下面这个样子：void f() throws tooBig, tooSmall, divZero { //...<br>...... |
| 9.3 标准Java违例                                             | Java包含了一个名为Throwable的类，它对可以作为违例“掷”出的所有东西进行了描述。Throwable对象有两种常规类型（亦即“从Throwable继承”）。其中，Error代表编译期和系统错误，我们一般不必特意捕获它们（除在特殊情况以外）。Exception是可以从任何标准Java库的类方法中“掷”出的基本类型。此外，它们亦可从我们自己的方法以及运行期偶发事件中“掷”出。 |
| 9.4 创建自己的违例                                           |                                                              |
| 9.5 违例的限制                                               |                                                              |
| 9.6 用finally清除                                            | 无论一个违例是否在try块中发生，我们经常都想执行一些特定的代码。为达到这个目的，可在所有违例控制器的末尾使用一个finally从句。所以完整的违例控制小节像下面这个样子：<br>try { <br/>// 要保卫的区域： <br/>// 可能“掷”出A,B的危险情况 <br/>} catch (A a1) { <br/>// 控制器 A <br/>} catch (B b1) {<br/> // 控制器 B <br/>}finally {<br/> // 每次都会发生的情况 <br/>}<br/><br/>无论是否“掷”出一个违例，finally从句都会执行。<br/>用finally做什么？<br/>1）对于没有垃圾收集机制的语言，finally极为重要，用于保证内存的正确释放（但Java有）<br/>2）若要设置另一些东西，finally就是必需的。例如，我们有时需要打开一个文件或者建立一个网络连接，或者在屏幕上画一些东西，甚至设置外部世界的一个开关，等等。<br/>如果没有finally，把2）中的操作放到catch中，那么万一没有catch到exception，就坏事了。 |
| *9.7 构建器                                                  |                                                              |
| *9.8 违例匹配                                                |                                                              |
| *9.9 总结                                                    |                                                              |
|                                                              |                                                              |
| *10 Java IO 系统                                             |                                                              |
|                                                              |                                                              |
| **11 运行期类型鉴定**                                        | 运行期类型鉴定（RTTI）的概念初看非常简单——手上只有基础类型的一个句柄时，利用它判断一个对象的正确类型。 然而，对RTTI的需要暴露出了面向对象设计许多有趣（而且经常是令人困惑的）的问题，并把程序的构造问题正式摆上了桌面。 本章将讨论如何利用Java在运行期间查找对象和类信息。这主要采取两种形式：一种是“传统”RTTI，它假定我们已在编译和运行期拥有所有类型；另一种是Java1.1特有的“反射”机制，利用它可在运行期独立查找类信息。首先讨论“传统”的RTTI，再讨论反射问题。 |
| **[11.1 对RTTI的需要](https://books.didispace.com/think-in-java/11.1%20%E5%AF%B9RTTI%E7%9A%84%E9%9C%80%E8%A6%81.html)** |                                                              |
| 11.2 RTTI语法                                                |                                                              |
| 11.3 反射：运行期类信息                                      |                                                              |
| 11.4 总结                                                    |                                                              |
|                                                              |                                                              |
| 12 传递和返回对象                                            | 准确地说，Java是有指针的！事实上，Java中每个对象（除基本数据类型以外）的标识符都属于指针的一种。但它们的使用受到了严格的限制和防范，不仅编译器对它们有“戒心”，运行期系统也不例外。或者换从另一个角度说，**Java有指针，但没有传统指针的麻烦。我曾一度将这种指针叫做“句柄”，但你可以把它想像成“安全指针”。**和预备学校为学生提供的安全剪刀类似——除非特别有意，否则不会伤着自己，只不过有时要慢慢来，要习惯一些沉闷的工作。 |
| 12.1 传递句柄                                                | 见 Berkeley CS61B 海象之谜                                   |
| 12.2 制作本地副本                                            | Java主要按值传递（无自变量），但对象却是按引用传递的。得到这个结论的前提是句柄只是对象的一个“别名”，所以不考虑传递句柄的问题，而是直接指出“我准备传递对象”。由于将其传递进入一个方法时没有获得对象的一个本地副本，所以对象显然不是按值传递的。Sun公司似乎在某种程度上支持这一见解，因为它“保留但未实现”的关键字之一便是byvalue（按值）。<br>克隆对象：若需修改一个对象，同时不想改变调用者的对象，就要制作该对象的一个本地副本。这也是本地副本最常见的一种用途。若决定制作一个本地副本，只需简单地使用clone()方法即可。Clone是“克隆”的意思，即制作完全一模一样的副本。这个方法在基础类Object中定义成“protected”（受保护）模式。但在希望克隆的任何衍生类中，必须将其覆盖为“public”模式。 |
| 12.3 克隆的控制                                              |                                                              |
| 12.4 可读类                                                  | 比如，String类的对象被设计成“不可变”。若查阅联机文档中关于String类的内容（本章稍后还要总结它），就会发现类中能够修改String的每个方法实际都创建和返回了一个崭新的String对象，新对象里包含了修改过的信息——原来的String是原封未动的。<br>由于String对象是不可变的，所以能够根据情况对一个特定的String进行多次别名处理。因为它是只读的，所以一个句柄不可能会改变一些会影响其他句柄的东西。因此，只读对象可以很好地解决别名问题。<br>但是与此同时带来了一个问题：我们最终目的只是获得包含了所有内容的一个新字串，但中间却要用到大量字串对象，而且要不断地进行垃圾收集。<br>解决的方法是象前面介绍的那样制作一个可变的同志类。对字串来说，这个同志类叫作StringBuffer。 |
| 12.5 总结                                                    |                                                              |
|                                                              |                                                              |
| 13 Java GUI                                                  |                                                              |
|                                                              |                                                              |
| 14 多线程                                                    |                                                              |
|                                                              |                                                              |
| 15 网络编程                                                  |                                                              |
|                                                              |                                                              |
| 16 设计模式                                                  |                                                              |





