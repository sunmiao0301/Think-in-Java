## Think in java

| 章节                                                         | 备注                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1 对象入门                                                   |                                                              |
| 1.1 抽象的进步                                               |                                                              |
| 1.2 对象的接口（方法）                                       |                                                              |
| 1.3 实现方案的隐藏                                           | 方案：访问控制                                               |
| 1.4 方案的重复使用                                           | 组织 —— 为重复使用一个类，最简单的办法是仅直接使用那个类的对象。但同时也能将那个类的一个对象置入一个新类。 |
| 1.5 继承：重新使用接口（方法）                               | 在Java中，继承是通过extends关键字实现的，使用继承时，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员（尽管private成员被隐藏起来，且不能访问），但更重要的是，它复制了父类的方法。<br>但是子类的对象不仅有和父类相同的类型，也有同样的行为，这一后果通常是我们不愿见到的。<br>对此，有两种做法可将新得的子类与原来的父类区分开。第一种做法十分简单：为衍生类添加新函数（功能）。第二个办法是改变基础类一个现有函数的行为。我们将其称作“重写”那个函数。 |
| 1.6 多形对象的互换使用                                       | 比如父类是Shape，且有一个函数需要Shape对象作为参数`void doStuff(Shape s)`，那么对于Shape的子类Circle的一个对象`Circle c = new Circle()`，我们也可以对其调用`doStuff(c)`，是安全的不会错误，我们将这种把子类当作它的父类处理的过程叫作“Upcasting”（上溯造型），这是怎么做到的呢？<br>将一条消息发给对象时，如果并不知道对方的具体类型是什么，但采取的行动同样是正确的，这种情况就叫作“多态性”（Polymorphism）。面向对象的程序设计语言，它们用以实现多态性的方法叫作“动态绑定”。编译器和运行期系统会负责对所有细节的控制；我们只需知道会发生什么事情，而且更重要的是，如何利用它帮助自己设计程序。<br>设计程序时，我们经常都希望父类只为自己的衍生类提供一个接口。也就是说，我们不想其他任何人实际创建父类的一个对象，只对上溯造型成它，以便使用它们的接口。为达到这个目的，需要把那个类变成“抽象”的——使用abstract关键字。若有人试图创建抽象类的一个对象，编译器就会阻止他们。这种工具可有效强制实行一种特殊的设计。<br>interface（接口）关键字将抽象类的概念更延伸了一步，它完全禁止了所有的函数定义。“接口”是一种相当有效和常用的工具。另外如果自己愿意，亦可对多个接口继承（但是类不支持多继承） |
| 1.7 对象的创建和存在时间                                     | 对象的创建及破坏方式：C++将对象放置在堆栈（有时也叫作自动或定域变量）或者静态存储区域，这种方法在编写程序时，必须知道对象的准确的数量、存在时间、以及类型。<br>第二个方法是在一个内存池中动态创建对象，该内存池亦叫“堆”或者“内存堆”。若采用这种方式，除非进入运行期，否则根本不知道到底需要多少个对象，也不知道它们的存在时间有多长，以及准确的类型是什么。这些参数都在程序正式运行时才决定的。若需一个新对象，只需在需要它的时候在内存堆里简单地创建它即可<br>Java垃圾收集器 —— 这意味着在Java程序执行期间，存在着一种不连贯的因素。所以在某些特殊的场合，我们必须避免用它<br>如果想对集合中的一系列元素进行操纵或比较，而不是仅仅面向一个，这时又该怎么办呢？办法就是使用一个“迭代器”（Iterator）<br>单根结构：Java中，所有类最终都从单独一个父类“Object”继承。这种“单根结构”具有许多方面的优点：<br>1）保证所有对象都拥有一些特定功能<br>2）单根结构，加上所有对象都在内存堆中创建，极大简化参数的传递<br>3）方便地实现一个垃圾收集器<br>p.s.C++没有选择单根结构<br>下溯造型，我们很难保证下溯造型的安全进行，除非确切地知道自己要操作的是什么。<br> |
| 1.8 违例控制：解决错误                                       | Exception —— Java的违例控制机制与大多数程序设计语言都有所不同。因为在Java中，违例控制模块是从一开始就封装好的，所以必须使用它！ |
| 1.9 多线程                                                   | 注意“共享资源”问题：Java的多线程机制已内建到语言中，对多线程处理的支持是在对象这一级支持的，所以一个执行线程可表达为一个对象。<br>Java也提供了有限的资源锁定方案。它能锁定任何对象占用的内存（内存实际是多种共享资源的一种），所以同一时间只能有一个线程使用特定的内存空间。为达到这个目的，需要使用synchronized关键字。其他类型的资源必须由程序员明确锁定，这通常要求程序员创建一个对象，用它代表一把锁，所有线程在访问那个资源时都必须检查这把锁。 |
| 1.10 永久性                                                  | 可将对象简单地保存到磁盘上，以后任何时间都可取回。           |
| 1.11 Java和因特网                                            | **[LINK](https://books.didispace.com/think-in-java/1.11%20Java%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91.html)** |
| 1.12 分析和设计                                              | 面向对象范式                                                 |
| 1.13 Java还是C++                                             | 相比C++，Java开发起来快，但是跑起来慢。—— （有人建议在开发期间使用Java，以缩短开发时间。然后用一个工具和支撑库将代码转换成C++，这样可获得更快的执行速度） |
|                                                              |                                                              |
| 2 一切都是对象                                               | C++支持与C语言的向后兼容能力，其中的某些特性使得C++过于复杂，Java则不必考虑这些，相对易学易用 |
| 2.1 用句柄操作对象                                           | 句柄（Handle） —— 实际上就是Java中我们常说的：对对象的引用，如`String s;`就是创建了一个String句柄，但这里创建的只是句柄，并不是对象。若此时向s发送一条消息，就会获得一个错误（运行期）。这是由于s实际并未与任何东西连接。因此，一种更安全的做法是：创建一个句柄时，记住无论如何都进行初始化：`String s = "asdf";` |
| 2.2 所有对象都必须创建                                       | 创建句柄时，我们希望它同一个新对象连接。通常用new关键字达到这一目的。<br>`String s = new String("asdf");` |
| 2.3 绝对不要清除对象                                         | Java中，基本数据类型是处在`{...}`作用域之内的：<br>{   <br>    int x = 12;   // only x available   <br/>    {     <br/>        int q = 96;     // both x & q available   <br/>    }   <br/>// only x available  <br/>// q “out of scope” <br/>}<br/><br/>Java对象不具备与基本数据类型一样的存在时间。用new关键字创建一个Java对象的时候，它会超出作用域的范围之外：<br>{ <br/>String s = new String("a string"); <br/>} // 作用域的终点 <br/><br/>很面明显，句柄s会在作用域的终点处消失。然而，s指向的String对象依然占据着内存空间。在上面这段代码里，我们没有办法访问对象，因为指向它的唯一一个句柄已超出了作用域的边界。<br/>正因为如此，Java中的垃圾收集器很关键。 |
| 2.4 新建数据类型：类                                         | 可在自己的类里设置两种类型的元素：数据成员（有时也叫“字段”）以及成员函数（通常叫“方法”）；每个对象都为自己的数据成员保有存储空间；数据成员不会在对象之间共享。<br><br>若某个基本数据类型属于一个类的字段，那么即使不明确（显式）进行初始化，也可以保证它们获得一个默认值。然而，这种保证却并不适用于“局部”变量——那些变量并非一个类的字段。所以，假若在一个函数定义中写入下述代码：`int x;`，那么x会得到一些随机值（这与C和C++是一样的），不会自动初始化成零。 |
| 2.5 方法、自变量和返回值                                     | Java的方法只能作为类的一部分创建。只能针对某个对象调用一个方法（注释③）<br>③：正如马上就要学到的那样，“静态”方法可针对类调用，毋需一个对象。<br><br>若返回类型为void，则return关键字唯一的作用就是退出方法。所以一旦抵达方法末尾，该关键字便不需要了。可在任何地方从一个方法返回。 |
| 2.6 构建Java程序                                             | 包 —— Java的这种特殊机制意味着所有文件都自动存在于自己的命名空间里，而且一个文件里的每个类都自动获得一个独一无二的标识符（当然，一个文件里的类名必须是唯一的）<br><br>2.6.3 **[static关键字](https://books.didispace.com/think-in-java/2.6%20%E6%9E%84%E5%BB%BAJava%E7%A8%8B%E5%BA%8F.html)**<br>通常，我们创建类时会指出那个类的对象的外观与行为。除非用new创建那个类的一个对象，否则实际上并未得到任何东西。只有执行了new后，才会正式生成数据存储空间，并可使用相应的方法。<br>但在两种特殊的情形下，上述方法并不堪用。一种情形是只想用一个存储区域来保存一个特定的数据——无论要创建多少个对象，甚至根本不创建对象。另一种情形是我们需要一个特殊的方法，它没有与这个类的任何对象关联。也就是说，即使没有创建对象，也需要一个能调用的方法。为满足这两方面的要求，可使用static（静态）关键字。一旦将什么东西设为static，数据或方法就不会同那个类的任何对象实例联系到一起。所以尽管从未创建那个类的一个对象，仍能调用一个static方法，或访问一些static数据。而在这之前，对于非static数据和方法，我们必须创建一个对象，并用那个对象访问数据或方法。这是由于非static数据和方法必须知道它们操作的具体对象。当然，在正式使用前，由于static方法不需要创建任何对象，所以它们不可简单地调用其他那些成员，同时不引用一个已命名的对象，从而直接访问非static成员或方法（因为非static成员和方法必须同一个特定的对象关联到一起）。 有些面向对象的语言使用了“类数据”和“类方法”这两个术语。它们意味着数据和方法只是为作为一个整体的类而存在的，并不是为那个类的任何特定对象。有时，您会在其他一些Java书刊里发现这样的称呼。<br>为了将数据成员或方法设为static，只需在定义前置和这个关键字即可。例如，下述代码能生成一个static数据成员，并对其初始化：<br>`class StaticTest { Static int i = 47; }`<br>`StaticTest st1 = new StaticTest();` <br>`StaticTest st2 = new StaticTest();`<br>现在，尽管我们制作了两个StaticTest对象，但它们仍然只占据StaticTest.i的一个存储空间。这两个对象都共享同样的i。此时，无论st1.i还是st2.i都有同样的值47，因为它们引用的是同样的内存区域。<br>有两个办法可引用一个static变量。正如上面展示的那样：<br>1）可通过一个对象命名它，如st2.i。<br>2）亦可直接用它的类名引用，而这在非静态成员里是行不通的（最好用这个办法引用static变量，因为它强调了那个变量的“静态”本质）。<br><br>static一项重要的用途就是帮助我们在不必创建对象的前提下调用那个方法。正如以后会看到的那样，这一点是至关重要的——特别是在定义程序运行入口方法main()的时候。 |
| 2.7 我们的第一个Java程序                                     | `public static void main(String[] args) {}`<br>其中，关键字“public”意味着方法可由外部世界调用（第5章会详细解释）。main()的自变量是包含了String对象的一个数组。args不会在本程序中用到，但需要在这个地方列出，因为它们保存了在命令行调用的自变量。 |
| 2.8 注释和嵌入文档                                           | **[2.8 注释和嵌入文档](https://books.didispace.com/think-in-java/2.8%20%E6%B3%A8%E9%87%8A%E5%92%8C%E5%B5%8C%E5%85%A5%E6%96%87%E6%A1%A3.html)** |
| 2.9 编码样式                                                 |                                                              |
| 2.10 总结                                                    |                                                              |
|                                                              |                                                              |
| 3.控制程序流程                                               |                                                              |
| 3.1 使用Java运算符                                           | 赋值操作<br>对主数据类型的赋值是非常直接的。由于主类型容纳了实际的值，而且并非指向一个对象的句柄，所以在为其赋值的时候，可将来自一个地方的内容复制到另一个地方。<br>但在为对象“赋值”的时候，情况却发生了变化。对一个对象进行操作时，我们真正操作的是它的句柄。所以倘若“从一个对象到另一个对象”赋值，实际就是将句柄从一个地方复制到另一个地方。这意味着假若为对象使用“C=D”，那么C和D最终都会指向最初只有D才指向的那个对象。<br><br>在许多程序设计语言中，f(Letter y)方法表面上似乎要在方法的作用域内制作自己的自变量Letter y的一个副本。但同样地，实际传递的是一个句柄。<br><br>算数运算符<br>整数除法会直接砍掉小数，而不是进位。<br/><br/>关系运算符—比较<br>== 和 equals<br/><br/>逻辑运算符—短路<br/><br/>按位运算符<br/><br/>移位运算符—有符号移位>> 无符号移位>>><br><br>在C和C++中，sizeof()运算符能满足我们的一项特殊需要：获知为数据项目分配的字符数量。Java不需要sizeof()运算符来满足这方面的需要，因为所有数据类型在所有机器的大小都是相同的。我们不必考虑移植问题——Java本身就是一种“与平台无关”的语言。 |
| 3.2 执行控制                                                 | Java里唯一用到逗号运算符的地方就是for循环的控制表达式。<br>`Switch` |
| 3.3 总结                                                     |                                                              |
|                                                              |                                                              |
| 4 初始化和清除                                               | “初始化”和“清除”是这些安全问题的其中两个。许多C程序的错误都是由于程序员忘记初始化一个变量造成的。对于现成的库，若用户不知道如何初始化库的一个组件，就往往会出现这一类的错误。清除是另一个特殊的问题，因为用完一个元素后，由于不再关心，所以很容易把它忘记。这样一来，那个元素占用的资源会一直保留下去，极易产生资源（主要是内存）用尽的后果。 |
| 4.1 用构建器自动初始化                                       | 构建器属于一种较特殊的方法类型，因为它没有返回值。这与void返回值存在着明显的区别。对于void返回值，尽管方法本身不会自动返回什么，但仍然可以让它返回另一些东西。构建器则不同，它不仅什么也不会自动返回，而且根本不能有任何选择。若存在一个返回值，而且假设我们可以自行选择返回内容，那么编译器多少要知道如何对那个返回值作什么样的处理。 |
| 4.2 方法过载                                                 | **在Java里，另一项因素强迫方法名出现重载情况：构建器。由于构建器的名字由类名决定，所以只能有一个构建器名称。**但假若我们想用多种方式创建一个对象呢？例如，假设我们想创建一个类，令其用标准方式进行初始化，另外从文件里读取信息来初始化。此时，我们需要两个构建器，一个没有自变量（默认构建器），另一个将字串作为自变量——用于初始化对象的那个文件的名字。由于都是构建器，所以它们必须有相同的名字，亦即类名。所以为了让相同的方法名伴随不同的自变量类型使用，“方法过载”是非常关键的一项措施。同时，尽管方法过载是构建器必需的，但它亦可应用于其他任何方法，且用法非常方便。<br><br/>自变量的顺序也足够我们区分两个方法，比如`void print(int i, String s)`和`void print(int i, String s)`（尽管我们通常不愿意采用这种方法，因为它会产生难以维护的代码）<br><br/>不能根据返回值类型来区分过载的方法。<br/><br>基本数据类型的重载，能从一个“较小”的类型自动转变成一个“较大”的类型。 若我们的自变量“大于”过载方法期望的自变量，这时又会出现什么情况呢？若我们的自变量范围比它宽，就必须用括号中的类型名将其转为适当的类型。如果不这样做，编译器会报告出错。大家可注意到这是一种“缩小转换”。也就是说，在造型或转型过程中可能丢失一些信息。这正是编译器强迫我们明确定义的原因——我们需明确表达想要转型的愿望，比如对于方法：<br/>public static double add(int i, double d){<br/>     return i + d; <br/>}<br/><br/>我们运行如下代码：<br/>int i = 1; <br/>double d = 2.0;<br/>System.out.println(add(i, d));//没问题<br/>System.out.println(add(i, i));//没问题<br/>System.out.println(add(d, d));//报错<br/><br/>当我们没有自己定义构造函数，那么编译程序将帮我们自动构建一个默认无参构造函数。但当我们已经定义了构造函数，编译程序就不会帮我们自动合成一个无参构造函数，此时如果再调用无参构造函数，就会报错：<br><br>假定我们在一个方法的内部，并希望获得当前对象的句柄。针对这一目的有个专用的关键字：this；**但要注意，假若准备从自己某个类的另一个方法内部调用一个类方法，就不必使用this。只需简单地调用那个方法即可。当前的this句柄会自动应用于其他方法。**this的另一项用途。由于自变量s的名字以及成员数据s的名字是相同的，所以会出现混淆。为解决这个问题，可用this.s来引用成员数据。经常都会在Java代码里看到这种形式的应用，本书的大量地方也采用了这种做法。 |
| 4.3 清除：收尾和垃圾收集                                     |                                                              |
| **[4.4 成员初始化-比较复杂](https://books.didispace.com/think-in-java/4.4%20%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96.html)** | 对于一个类，如果你对其中的字段都不进行初始化，那么字段中的所有基本类型数据成员都会保证获得一个初始值（0，false等）。在一个类的内部定义一个对象句柄时，如果不将其初始化成新对象，那个句柄就会获得一个空值NULL。<br><br>初始化比较常见的方法是：<br>1）最直接的做法是在类内部定义变量的同时也为其赋值<br>class Measurement {<br>   boolean b = true;<br/>   Depth d = new Depth();<br>}<br/>2）通过构造函数初始化<br>class Counter {<br/>   int i; <br/>   Counter() { i = 7; }<br/>}<br/>3）对每个字段，即在定义时初始化，也在构造函数调用时；<br>从表面看，这样做似乎效率低下，但它能保证正确的初始化——若定义了一个过载的构建器，它没有初始化t3；同时在t3的定义里并没有规定“默认”的初始化方式，可能会造成严重后果。 |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |
|                                                              |                                                              |





