## Think in java

| 章节                           | 备注                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| 1 对象入门                     |                                                              |
| 1.1 抽象的进步                 |                                                              |
| 1.2 对象的接口（方法）         |                                                              |
| 1.3 实现方案的隐藏             | 方案：访问控制                                               |
| 1.4 方案的重复使用             | 组织 —— 为重复使用一个类，最简单的办法是仅直接使用那个类的对象。但同时也能将那个类的一个对象置入一个新类。 |
| 1.5 继承：重新使用接口（方法） | 在Java中，继承是通过extends关键字实现的，使用继承时，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员（尽管private成员被隐藏起来，且不能访问），但更重要的是，它复制了父类的方法。<br>但是子类的对象不仅有和父类相同的类型，也有同样的行为，这一后果通常是我们不愿见到的。<br>对此，有两种做法可将新得的子类与原来的父类区分开。第一种做法十分简单：为衍生类添加新函数（功能）。第二个办法是改变基础类一个现有函数的行为。我们将其称作“重写”那个函数。 |
| 1.6 多形对象的互换使用         | 比如父类是Shape，且有一个函数需要Shape对象作为参数`void doStuff(Shape s)`，那么对于Shape的子类Circle的一个对象`Circle c = new Circle()`，我们也可以对其调用`doStuff(c)`，是安全的不会错误，我们将这种把子类当作它的父类处理的过程叫作“Upcasting”（上溯造型），这是怎么做到的呢？<br>将一条消息发给对象时，如果并不知道对方的具体类型是什么，但采取的行动同样是正确的，这种情况就叫作“多态性”（Polymorphism）。面向对象的程序设计语言，它们用以实现多态性的方法叫作“动态绑定”。编译器和运行期系统会负责对所有细节的控制；我们只需知道会发生什么事情，而且更重要的是，如何利用它帮助自己设计程序。<br>设计程序时，我们经常都希望父类只为自己的衍生类提供一个接口。也就是说，我们不想其他任何人实际创建父类的一个对象，只对上溯造型成它，以便使用它们的接口。为达到这个目的，需要把那个类变成“抽象”的——使用abstract关键字。若有人试图创建抽象类的一个对象，编译器就会阻止他们。这种工具可有效强制实行一种特殊的设计。<br>interface（接口）关键字将抽象类的概念更延伸了一步，它完全禁止了所有的函数定义。“接口”是一种相当有效和常用的工具。另外如果自己愿意，亦可对多个接口继承（但是类不支持多继承） |
| 1.7 对象的创建和存在时间       | 对象的创建及破坏方式：C++将对象放置在堆栈（有时也叫作自动或定域变量）或者静态存储区域，这种方法在编写程序时，必须知道对象的准确的数量、存在时间、以及类型。<br>第二个方法是在一个内存池中动态创建对象，该内存池亦叫“堆”或者“内存堆”。若采用这种方式，除非进入运行期，否则根本不知道到底需要多少个对象，也不知道它们的存在时间有多长，以及准确的类型是什么。这些参数都在程序正式运行时才决定的。若需一个新对象，只需在需要它的时候在内存堆里简单地创建它即可<br>Java垃圾收集器 —— 这意味着在Java程序执行期间，存在着一种不连贯的因素。所以在某些特殊的场合，我们必须避免用它<br>如果想对集合中的一系列元素进行操纵或比较，而不是仅仅面向一个，这时又该怎么办呢？办法就是使用一个“迭代器”（Iterator）<br>单根结构：Java中，所有类最终都从单独一个父类“Object”继承。这种“单根结构”具有许多方面的优点：<br>1）保证所有对象都拥有一些特定功能<br>2）单根结构，加上所有对象都在内存堆中创建，极大简化参数的传递<br>3）方便地实现一个垃圾收集器<br>p.s.C++没有选择单根结构<br>下溯造型，我们很难保证下溯造型的安全进行，除非确切地知道自己要操作的是什么。<br> |
| 1.8 违例控制：解决错误         | Exception —— Java的违例控制机制与大多数程序设计语言都有所不同。因为在Java中，违例控制模块是从一开始就封装好的，所以必须使用它！ |
| 1.9 多线程                     | 注意“共享资源”问题：Java的多线程机制已内建到语言中，对多线程处理的支持是在对象这一级支持的，所以一个执行线程可表达为一个对象。<br>Java也提供了有限的资源锁定方案。它能锁定任何对象占用的内存（内存实际是多种共享资源的一种），所以同一时间只能有一个线程使用特定的内存空间。为达到这个目的，需要使用synchronized关键字。其他类型的资源必须由程序员明确锁定，这通常要求程序员创建一个对象，用它代表一把锁，所有线程在访问那个资源时都必须检查这把锁。 |
| 1.10 永久性                    | 可将对象简单地保存到磁盘上，以后任何时间都可取回。           |
| 1.11 Java和因特网              | **[LINK](https://books.didispace.com/think-in-java/1.11%20Java%E5%92%8C%E5%9B%A0%E7%89%B9%E7%BD%91.html)** |
| 1.12 分析和设计                | 面向对象范式                                                 |
| 1.13 Java还是C++               |                                                              |
|                                |                                                              |
|                                |                                                              |





